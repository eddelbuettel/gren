/bin/bash: warning: setlocale: LC_ALL: cannot change locale (UTF-8)

R version 3.4.4 (2018-03-15) -- "Someone to Lean On"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

During startup - Warning messages:
1: Setting LC_CTYPE failed, using "C" 
2: Setting LC_COLLATE failed, using "C" 
3: Setting LC_TIME failed, using "C" 
4: Setting LC_MESSAGES failed, using "C" 
5: Setting LC_MONETARY failed, using "C" 
6: Setting LC_PAPER failed, using "C" 
7: Setting LC_MEASUREMENT failed, using "C" 
> path.data <- as.character(ifelse(Sys.info()[1]=="Darwin", "/Users/magnusmunch/Documents/OneDrive/PhD/EBEN/data/" , "~/EBEN/data/"))
> path.res <- ifelse(as.character(Sys.info()[1])!="Darwin", "~/EBEN/results/",
+                    "/Users/magnusmunch/Documents/OneDrive/PhD/EBEN/results/")
> 
> library(gren)
> library(pROC)
Type 'citation("pROC")' for a citation.

Attaching package: 'pROC'

The following objects are masked from 'package:stats':

    cov, smooth, var

> library(GRridge)
Loading required package: penalized
Loading required package: survival
Welcome to penalized. For extended examples, see vignette("penalized").
Loading required package: Iso
Iso 0.0-17
Loading required package: graph
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: 'BiocGenerics'

The following objects are masked from 'package:parallel':

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following object is masked from 'package:penalized':

    as.data.frame

The following object is masked from 'package:pROC':

    var

The following objects are masked from 'package:stats':

    IQR, mad, sd, var, xtabs

The following objects are masked from 'package:base':

    Filter, Find, Map, Position, Reduce, anyDuplicated, append,
    as.data.frame, cbind, colMeans, colSums, colnames, do.call,
    duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted,
    lapply, lengths, mapply, match, mget, order, paste, pmax, pmax.int,
    pmin, pmin.int, rank, rbind, rowMeans, rowSums, rownames, sapply,
    setdiff, sort, table, tapply, union, unique, unsplit, which,
    which.max, which.min

Loading required package: glmnet
Loading required package: Matrix
Loading required package: foreach
Loaded glmnet 2.0-16


Attaching package: 'glmnet'

The following object is masked from 'package:pROC':

    auc

Loading required package: mvtnorm

Attaching package: 'GRridge'

The following object is masked from 'package:glmnet':

    auc

The following objects are masked from 'package:pROC':

    auc, roc

> library(grpreg)
> library(SGL)
> library(Hmisc)
Loading required package: lattice
Loading required package: Formula
Loading required package: ggplot2

Attaching package: 'Hmisc'

The following objects are masked from 'package:base':

    format.pval, units

> library(Biobase)
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.


Attaching package: 'Biobase'

The following object is masked from 'package:Hmisc':

    contents

> 
> # colors <- bpy.colors(5)[-c(1, 5)]
> 
> load(paste(path.data, "ESetMbolCSFPR2.Rdata", sep=""))
> 
> x <- apply(t(exprs(ESetMbolCSFPR2)), 2, function(x) {(x - mean(x))/sd(x)})
> y <- as.numeric(pData(ESetMbolCSFPR2)$D_diag_name) - 1
> 
> part1 <- replace(fData(ESetMbolCSFPR2)$PlatformCode, 
+                  fData(ESetMbolCSFPR2)$PlatformCode==5, 4)
> part2 <- fData(ESetMbolCSFPR2)$PlatformCode
> part3 <- as.numeric(cut2(fData(ESetMbolCSFPR2)$RSDqc, g=3))
> part4 <- as.numeric(cut2(fData(ESetMbolCSFPR2)$RSDqc, 0.06))
> 
> labels1 <- replace(levels(fData(ESetMbolCSFPR2)$Platform)[-5],
+                    levels(fData(ESetMbolCSFPR2)$Platform)[-5]==
+                      "Oxidative Stress high pH", "Oxidate Stress")
> labels2 <- levels(fData(ESetMbolCSFPR2)$Platform)
> labels3 <- levels(cut2(fData(ESetMbolCSFPR2)$RSDqc, g=3))
> labels4 <- levels(cut2(fData(ESetMbolCSFPR2)$RSDqc, 0.06))
> 
> n <- nrow(x)
> p <- ncol(x)
> # set.seed(2016)
> # idtrain <- sample(c(1:n), floor(n/2))
> # xtrain <- x[idtrain, ]
> # xtest <- x[-idtrain, ]
> # ytrain <- y[idtrain]
> # ytest <- y[-idtrain]
> # 
> # fit1.gren1 <- gren(xtrain, ytrain, partitions=list(platform=part1), alpha=0.05)
> # fit1.gren2 <- gren(xtrain, ytrain, partitions=list(platform=part1), alpha=0.5)
> # fit1.gren3 <- gren(xtrain, ytrain, partitions=list(platform=part1), alpha=0.95)
> # 
> # pred1.gren1 <- predict(fit1.gren1, xtest, type="groupreg",
> #                        s=fit1.gren1$freq.model$groupreg$lambda)
> # pred1.gren2 <- predict(fit1.gren2, xtest, type="groupreg",
> #                        s=fit1.gren2$freq.model$groupreg$lambda)
> # pred1.gren3 <- predict(fit1.gren3, xtest, type="groupreg",
> #                        s=fit1.gren3$freq.model$groupreg$lambda)
> # 
> # pred1.enet1 <- predict(fit1.gren1, xtest, type="regular",
> #                        s=fit1.gren1$freq.model$regular$lambda)
> # pred1.enet2 <- predict(fit1.gren2, xtest, type="regular",
> #                        s=fit1.gren2$freq.model$regular$lambda)
> # pred1.enet3 <- predict(fit1.gren3, xtest, type="regular",
> #                        s=fit1.gren3$freq.model$regular$lambda)
> # 
> # 
> # 
> # psel1.gren1 <- fit1.gren1$freq.model$groupreg$df
> # psel1.gren2 <- fit1.gren2$freq.model$groupreg$df
> # psel1.gren3 <- fit1.gren3$freq.model$groupreg$df
> # 
> # psel1.enet1 <- fit1.gren1$freq.model$regular$df
> # psel1.enet2 <- fit1.gren2$freq.model$regular$df
> # psel1.enet3 <- fit1.gren3$freq.model$regular$df
> # 
> # auc1.gren1 <- apply(pred1.gren1, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc1.gren2 <- apply(pred1.gren2, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc1.gren3 <- apply(pred1.gren3, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # 
> # auc1.enet1 <- apply(pred1.enet1, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc1.enet2 <- apply(pred1.enet2, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc1.enet3 <- apply(pred1.enet3, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # 
> # results1 <- list(idtrain=idtrain,
> #                  pred=list(enet1=pred1.enet1, enet2=pred1.enet2, 
> #                            enet3=pred1.enet3, gren1=pred1.gren1, 
> #                            gren2=pred1.gren2, gren3=pred1.gren3),
> #                  psel=list(enet1=psel1.enet1, enet2=psel1.enet2, 
> #                            enet3=psel1.enet3, gren1=psel1.gren1, 
> #                            gren2=psel1.gren2, gren3=psel1.gren3),
> #                  auc=list(enet1=auc1.enet1, enet2=auc1.enet2, enet3=auc1.enet3, 
> #                           gren1=auc1.gren1, gren2=auc1.gren2, gren3=auc1.gren3))
> # 
> # plot(sort(results1$psel$enet1), results1$auc$enet1[order(results1$psel$enet1)], 
> #      type="l", xlim=range(results1$psel), ylim=range(results1$auc), lty=2,
> #      col=colors[1])
> # lines(sort(results1$psel$enet2), results1$auc$enet2[order(results1$psel$enet2)],
> #       lty=2, col=colors[2])
> # lines(sort(results1$psel$enet3), results1$auc$enet3[order(results1$psel$enet2)],
> #       lty=2, col=colors[3])
> # 
> # lines(sort(results1$psel$gren1), results1$auc$gren1[order(results1$psel$gren1)],
> #      lty=1, col=colors[1])
> # lines(sort(results1$psel$gren2), results1$auc$gren2[order(results1$psel$gren2)],
> #       lty=1, col=colors[2])
> # lines(sort(results1$psel$gren3), results1$auc$gren3[order(results1$psel$gren3)],
> #       lty=1, col=colors[3])
> # 
> # 
> # #####
> # fit2.gren1 <- gren(xtrain, ytrain, partitions=list(platform=part2), alpha=0.05)
> # fit2.gren2 <- gren(xtrain, ytrain, partitions=list(platform=part2), alpha=0.5)
> # fit2.gren3 <- gren(xtrain, ytrain, partitions=list(platform=part2), alpha=0.95)
> # 
> # pred2.gren1 <- predict(fit2.gren1, xtest, type="groupreg",
> #                        s=fit2.gren1$freq.model$groupreg$lambda)
> # pred2.gren2 <- predict(fit2.gren2, xtest, type="groupreg",
> #                        s=fit2.gren2$freq.model$groupreg$lambda)
> # pred2.gren3 <- predict(fit2.gren3, xtest, type="groupreg",
> #                        s=fit2.gren3$freq.model$groupreg$lambda)
> # 
> # pred2.enet1 <- predict(fit2.gren1, xtest, type="regular",
> #                        s=fit2.gren1$freq.model$regular$lambda)
> # pred2.enet2 <- predict(fit2.gren2, xtest, type="regular",
> #                        s=fit2.gren2$freq.model$regular$lambda)
> # pred2.enet3 <- predict(fit2.gren3, xtest, type="regular",
> #                        s=fit2.gren3$freq.model$regular$lambda)
> # 
> # psel2.gren1 <- fit2.gren1$freq.model$groupreg$df
> # psel2.gren2 <- fit2.gren2$freq.model$groupreg$df
> # psel2.gren3 <- fit2.gren3$freq.model$groupreg$df
> # 
> # psel2.enet1 <- fit2.gren1$freq.model$regular$df
> # psel2.enet2 <- fit2.gren2$freq.model$regular$df
> # psel2.enet3 <- fit2.gren3$freq.model$regular$df
> # 
> # auc2.gren1 <- apply(pred2.gren1, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc2.gren2 <- apply(pred2.gren2, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc2.gren3 <- apply(pred2.gren3, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # 
> # auc2.enet1 <- apply(pred2.enet1, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc2.enet2 <- apply(pred2.enet2, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc2.enet3 <- apply(pred2.enet3, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # 
> # results2 <- list(idtrain=idtrain,
> #                  pred=list(enet1=pred2.enet1, enet2=pred2.enet2, 
> #                            enet3=pred2.enet3, gren1=pred2.gren1, 
> #                            gren2=pred2.gren2, gren3=pred2.gren3),
> #                  psel=list(enet1=psel2.enet1, enet2=psel2.enet2, 
> #                            enet3=psel2.enet3, gren1=psel2.gren1, 
> #                            gren2=psel2.gren2, gren3=psel2.gren3),
> #                  auc=list(enet1=auc2.enet1, enet2=auc2.enet2, enet3=auc2.enet3, 
> #                           gren1=auc2.gren1, gren2=auc2.gren2, gren3=auc2.gren3))
> # 
> # plot(sort(results2$psel$enet1), results2$auc$enet1[order(results2$psel$enet1)], 
> #      type="l", xlim=range(results2$psel), ylim=range(results2$auc), lty=2,
> #      col=colors[1])
> # lines(sort(results2$psel$enet2), results2$auc$enet2[order(results2$psel$enet2)],
> #       lty=2, col=colors[2])
> # lines(sort(results2$psel$enet3), results2$auc$enet3[order(results2$psel$enet2)],
> #       lty=2, col=colors[3])
> # 
> # lines(sort(results2$psel$gren1), results2$auc$gren1[order(results2$psel$gren1)],
> #       lty=1, col=colors[1])
> # lines(sort(results2$psel$gren2), results2$auc$gren2[order(results2$psel$gren2)],
> #       lty=1, col=colors[2])
> # lines(sort(results2$psel$gren3), results2$auc$gren3[order(results2$psel$gren3)],
> #       lty=1, col=colors[3])
> 
> 
> 
> 
> 
> # ####
> # fit3.gren1 <- gren(xtrain, ytrain, partitions=list(RSDqc=part3), alpha=0.05)
> # fit3.gren2 <- gren(xtrain, ytrain, partitions=list(RSDqc=part3), alpha=0.5)
> # fit3.gren3 <- gren(xtrain, ytrain, partitions=list(RSDqc=part3), alpha=0.95)
> # 
> 
> 
> psel <- c(seq(1, 5, 1), seq(7, 15, 2), seq(20, 40, 5), seq(50, 90, 10), seq(110, 150, 20))
> 
> set.seed(2018)
> nfolds <- n
> rest <- n %% nfolds
> foldid <- sample(rep(1:nfolds, times=round(c(rep(
+   n %/% nfolds + as.numeric(rest!=0), times=rest),
+   rep(n %/% nfolds, times=nfolds - rest)))))
> 
> pred3 <- list(ridge=numeric(n),
+               grridge=matrix(NA, nrow=n, ncol=length(psel)),
+               enet1=matrix(NA, nrow=n, ncol=length(psel)),
+               enet2=matrix(NA, nrow=n, ncol=length(psel)),
+               enet3=matrix(NA, nrow=n, ncol=length(psel)),
+               gren1=matrix(NA, nrow=n, ncol=length(psel)),
+               gren2=matrix(NA, nrow=n, ncol=length(psel)),
+               gren3=matrix(NA, nrow=n, ncol=length(psel)),
+               sglasso1=vector("list", n),
+               sglasso2=vector("list", n),
+               sglasso3=vector("list", n),
+               cmcp1=vector("list", n),
+               cmcp2=vector("list", n),
+               cmcp3=vector("list", n),
+               gelasso1=vector("list", n),
+               gelasso2=vector("list", n),
+               gelasso3=vector("list", n))
> psel3 <- list(grridge=matrix(NA, nrow=n, ncol=length(psel)),
+               enet1=matrix(NA, nrow=n, ncol=length(psel)),
+               enet2=matrix(NA, nrow=n, ncol=length(psel)),
+               enet3=matrix(NA, nrow=n, ncol=length(psel)),
+               gren1=matrix(NA, nrow=n, ncol=length(psel)),
+               gren2=matrix(NA, nrow=n, ncol=length(psel)),
+               gren3=matrix(NA, nrow=n, ncol=length(psel)),
+               sglasso1=vector("list", n),
+               sglasso2=vector("list", n),
+               sglasso3=vector("list", n),
+               cmcp1=vector("list", n),
+               cmcp2=vector("list", n),
+               cmcp3=vector("list", n),
+               gelasso1=vector("list", n),
+               gelasso2=vector("list", n),
+               gelasso3=vector("list", n))
> 
> 
> for(k in 1:nfolds) {
+   cat(paste("Fold ", k, "\n"))
+   
+   xtrain <- x[foldid!=k, ]
+   xtest <- matrix(x[foldid==k, ], ncol=p, byrow=TRUE)
+   ytrain <- y[foldid!=k]
+   
+   fit3.ridge <- cv.glmnet(xtrain, ytrain, alpha=0, standardize=FALSE)
+   
+   fit3.grridge <- vector("list", length(psel))
+   invisible(capture.output(
+     fit3.grridge[[1]] <- grridge(t(xtrain), ytrain, partitions=list(
+       RSDqc=CreatePartition(as.factor(part3))), selection=TRUE, maxsel=psel[1],
+       trace=FALSE, standardizeX=FALSE)))
+   for(s in 2:length(psel)) {
+     invisible(capture.output(
+       fit3.grridge[[s]] <- grridge(t(xtrain), ytrain, partitions=list(
+         RSDqc=CreatePartition(as.factor(part3))), selection=TRUE,
+         maxsel=psel[s], optl=fit3.grridge[[1]]$optl, trace=FALSE,
+         standardizeX=FALSE)))
+   }
+   
+   fit3.gren1 <- gren(xtrain, ytrain, partitions=list(RSDqc=part3), alpha=0.05,
+                      psel=psel, trace=FALSE)
+   fit3.gren2 <- gren(xtrain, ytrain, partitions=list(RSDqc=part3), alpha=0.5,
+                      psel=psel, trace=FALSE)
+   fit3.gren3 <- gren(xtrain, ytrain, partitions=list(RSDqc=part3), alpha=0.95,
+                      psel=psel, trace=FALSE)
+   
+   fit3.sglasso1 <- SGL(list(x=xtrain, y=ytrain), part3, type="logit", 
+                        alpha=0.05, standardize=FALSE, nlam=100)
+   fit3.sglasso2 <- SGL(list(x=xtrain, y=ytrain), part3, type="logit", alpha=0.5,
+                        standardize=FALSE, nlam=100)
+   fit3.sglasso3 <- SGL(list(x=xtrain, y=ytrain), part3, type="logit", 
+                        alpha=0.95, standardize=FALSE, nlam=100)
+   
+   fit3.cmcp1 <- grpreg(xtrain, ytrain, part3, penalty="cMCP", alpha=0.05)
+   fit3.cmcp2 <- grpreg(xtrain, ytrain, part3, penalty="cMCP", alpha=0.5)
+   fit3.cmcp3 <- grpreg(xtrain, ytrain, part3, penalty="cMCP", alpha=0.95)
+   
+   fit3.gelasso1 <- grpreg(xtrain, ytrain, part3, penalty="gel", alpha=0.05)
+   fit3.gelasso2 <- grpreg(xtrain, ytrain, part3, penalty="gel", alpha=0.5)
+   fit3.gelasso3 <- grpreg(xtrain, ytrain, part3, penalty="gel", alpha=0.95)
+   
+   # predictions
+   pred3$ridge[foldid==k] <- as.numeric(predict(fit3.ridge, xtest, "lambda.min"))
+   
+   pred3$grridge[foldid==k, ] <- sapply(fit3.grridge, function(s) {
+     predict.grridge(s, t(xtest))[, 3]})
+   
+   pred3$gren1[foldid==k, ] <- predict(fit3.gren1, xtest, type="groupreg",
+                                       s=fit3.gren1$freq.model$groupreg$lambda)
+   pred3$gren2[foldid==k, ] <- predict(fit3.gren2, xtest, type="groupreg",
+                                       s=fit3.gren2$freq.model$groupreg$lambda)
+   pred3$gren3[foldid==k, ] <- predict(fit3.gren3, xtest, type="groupreg",
+                                       s=fit3.gren3$freq.model$groupreg$lambda)
+   
+   pred3$enet1[foldid==k, ] <- predict(fit3.gren1, xtest, type="regular",
+                                       s=fit3.gren1$freq.model$regular$lambda)
+   pred3$enet2[foldid==k, ] <- predict(fit3.gren2, xtest, type="regular",
+                                       s=fit3.gren2$freq.model$regular$lambda)
+   pred3$enet3[foldid==k, ] <- predict(fit3.gren3, xtest, type="regular",
+                                       s=fit3.gren3$freq.model$regular$lambda)
+   
+   pred3$sglasso1[[which(foldid==k)]] <- predictSGL(fit3.sglasso1, xtest)
+   pred3$sglasso2[[which(foldid==k)]] <- predictSGL(fit3.sglasso2, xtest)
+   pred3$sglasso3[[which(foldid==k)]] <- predictSGL(fit3.sglasso3, xtest)
+   
+   pred3$cmcp1[[which(foldid==k)]] <- predict(fit3.cmcp1, xtest)
+   pred3$cmcp2[[which(foldid==k)]] <- predict(fit3.cmcp2, xtest)
+   pred3$cmcp3[[which(foldid==k)]] <- predict(fit3.cmcp3, xtest)
+   
+   pred3$gelasso1[[which(foldid==k)]] <- predict(fit3.gelasso1, xtest)
+   pred3$gelasso2[[which(foldid==k)]] <- predict(fit3.gelasso2, xtest)
+   pred3$gelasso3[[which(foldid==k)]] <- predict(fit3.gelasso3, xtest)
+   
+   # number of selected variables
+   psel3$grridge[foldid==k, ] <- sapply(fit3.grridge, function(s) {
+     length(s$resEN$whichEN)})
+   
+   psel3$gren1[foldid==k, ] <- fit3.gren1$freq.model$groupreg$df
+   psel3$gren2[foldid==k, ] <- fit3.gren2$freq.model$groupreg$df
+   psel3$gren3[foldid==k, ] <- fit3.gren3$freq.model$groupreg$df
+   
+   psel3$enet1[foldid==k, ] <- fit3.gren1$freq.model$regular$df
+   psel3$enet2[foldid==k, ] <- fit3.gren2$freq.model$regular$df
+   psel3$enet3[foldid==k, ] <- fit3.gren3$freq.model$regular$df
+   
+   psel3$sglasso1[[which(foldid==k)]] <- apply(
+     fit3.sglasso1$beta, 2, function(b) {sum(b!=0)})
+   psel3$sglasso2[[which(foldid==k)]] <- apply(
+     fit3.sglasso2$beta, 2, function(b) {sum(b!=0)})
+   psel3$sglasso3[[which(foldid==k)]] <- apply(
+     fit3.sglasso3$beta, 2, function(b) {sum(b!=0)})
+   
+   psel3$cmcp1[[which(foldid==k)]] <- apply(
+     fit3.cmcp1$beta, 2, function(b) {sum(b!=0)})
+   psel3$cmcp2[[which(foldid==k)]] <- apply(
+     fit3.cmcp2$beta, 2, function(b) {sum(b!=0)})
+   psel3$cmcp3[[which(foldid==k)]] <- apply(
+     fit3.cmcp3$beta, 2, function(b) {sum(b!=0)})
+   
+   psel3$gelasso1[[which(foldid==k)]] <- apply(
+     fit3.gelasso1$beta, 2, function(b) {sum(b!=0)})
+   psel3$gelasso2[[which(foldid==k)]] <- apply(
+     fit3.gelasso2$beta, 2, function(b) {sum(b!=0)})
+   psel3$gelasso3[[which(foldid==k)]] <- apply(
+     fit3.gelasso3$beta, 2, function(b) {sum(b!=0)})
+   
+   results3 <- list(pred=pred3, psel=psel3)
+   save(results3, file=paste(path.res, "gren_metabol_alzheimer_res1.Rdata", sep=""))
+ }
Fold  1 
Fold  2 
Fold  3 
Fold  4 
Fold  5 
Fold  6 
Fold  7 
Fold  8 
Fold  9 
Fold  10 
Fold  11 
Fold  12 
Fold  13 
Fold  14 
Fold  15 
Fold  16 
Fold  17 
Fold  18 
Fold  19 
Fold  20 
Fold  21 
Fold  22 
Fold  23 
Fold  24 
Fold  25 
Fold  26 
Fold  27 
Fold  28 
Fold  29 
Fold  30 
Fold  31 
Fold  32 
Fold  33 
Fold  34 
Fold  35 
Fold  36 
Fold  37 
Fold  38 
Fold  39 
Fold  40 
Fold  41 
Fold  42 
Fold  43 
Fold  44 
Fold  45 
Fold  46 
Fold  47 
Fold  48 
Fold  49 
Fold  50 
Fold  51 
Fold  52 
Fold  53 
Fold  54 
Fold  55 
Fold  56 
Fold  57 
Fold  58 
Fold  59 
Fold  60 
Fold  61 
Fold  62 
Fold  63 
Fold  64 
Fold  65 
Fold  66 
Fold  67 
Fold  68 
Fold  69 
Fold  70 
Fold  71 
Fold  72 
Fold  73 
Fold  74 
Fold  75 
Fold  76 
Fold  77 
Fold  78 
Fold  79 
Fold  80 
Fold  81 
Fold  82 
Fold  83 
Fold  84 
Fold  85 
Fold  86 
Fold  87 
Fold  88 
Fold  89 
Fold  90 
Fold  91 
Fold  92 
Fold  93 
Fold  94 
Fold  95 
Fold  96 
Fold  97 
Fold  98 
Fold  99 
Fold  100 
Fold  101 
Fold  102 
Fold  103 
Fold  104 
Fold  105 
Fold  106 
Fold  107 
Fold  108 
Fold  109 
Fold  110 
Fold  111 
Fold  112 
Fold  113 
Fold  114 
Fold  115 
Fold  116 
Fold  117 
Fold  118 
Fold  119 
Fold  120 
Fold  121 
Fold  122 
Fold  123 
Fold  124 
Fold  125 
Fold  126 
Fold  127 
Fold  128 
Fold  129 
Fold  130 
Fold  131 
Fold  132 
Fold  133 
Fold  134 
Fold  135 
Fold  136 
Fold  137 
Fold  138 
Fold  139 
Fold  140 
Fold  141 
Fold  142 
Fold  143 
Fold  144 
Fold  145 
Fold  146 
Fold  147 
Fold  148 
Fold  149 
Fold  150 
Fold  151 
Fold  152 
Fold  153 
Fold  154 
Fold  155 
Fold  156 
Fold  157 
Fold  158 
Fold  159 
Fold  160 
Fold  161 
Fold  162 
Fold  163 
Fold  164 
Fold  165 
Fold  166 
Fold  167 
Fold  168 
Fold  169 
Fold  170 
Fold  171 
Fold  172 
Fold  173 
Fold  174 
Fold  175 
Fold  176 
Fold  177 
Fold  178 
Fold  179 
Fold  180 
Fold  181 
Fold  182 
Fold  183 
Fold  184 
Fold  185 
Fold  186 
Fold  187 
Fold  188 
Fold  189 
Fold  190 
Fold  191 
Fold  192 
Fold  193 
Fold  194 
Fold  195 
Fold  196 
Fold  197 
Fold  198 
Fold  199 
Fold  200 
Fold  201 
Fold  202 
Fold  203 
Fold  204 
Fold  205 
Fold  206 
Fold  207 
Fold  208 
Fold  209 
Fold  210 
Fold  211 
Fold  212 
Fold  213 
Fold  214 
Fold  215 
Fold  216 
Fold  217 
Fold  218 
Fold  219 
Fold  220 
Fold  221 
Fold  222 
Fold  223 
Fold  224 
Fold  225 
Fold  226 
Fold  227 
Fold  228 
Fold  229 
Fold  230 
Fold  231 
Fold  232 
Fold  233 
Fold  234 
Fold  235 
Fold  236 
Fold  237 
Fold  238 
Fold  239 
Fold  240 
Fold  241 
Fold  242 
Fold  243 
Fold  244 
Fold  245 
Fold  246 
Fold  247 
Fold  248 
> 
> # cv3.gren1 <- cv.gren(x, y, partitions=list(RSDqc=part3), alpha=0.05)
> # cv3.gren2 <- cv.gren(x, y, partitions=list(RSDqc=part3), alpha=0.5)
> # cv3.gren3 <- cv.gren(x, y, partitions=list(RSDqc=part3), alpha=0.95)
> # 
> # pred3.gren1 <- predict(fit3.gren1, xtest, type="groupreg",
> #                        s=fit3.gren1$freq.model$groupreg$lambda)
> # pred3.gren2 <- predict(fit3.gren2, xtest, type="groupreg",
> #                        s=fit3.gren2$freq.model$groupreg$lambda)
> # pred3.gren3 <- predict(fit3.gren3, xtest, type="groupreg",
> #                        s=fit3.gren3$freq.model$groupreg$lambda)
> # 
> # pred3.enet1 <- predict(fit3.gren1, xtest, type="regular",
> #                        s=fit3.gren1$freq.model$regular$lambda)
> # pred3.enet2 <- predict(fit3.gren2, xtest, type="regular",
> #                        s=fit3.gren2$freq.model$regular$lambda)
> # pred3.enet3 <- predict(fit3.gren3, xtest, type="regular",
> #                        s=fit3.gren3$freq.model$regular$lambda)
> # 
> # psel3.gren1 <- fit3.gren1$freq.model$groupreg$df
> # psel3.gren2 <- fit3.gren2$freq.model$groupreg$df
> # psel3.gren3 <- fit3.gren3$freq.model$groupreg$df
> # 
> # psel3.enet1 <- fit3.gren1$freq.model$regular$df
> # psel3.enet2 <- fit3.gren2$freq.model$regular$df
> # psel3.enet3 <- fit3.gren3$freq.model$regular$df
> # 
> # auc3.gren1 <- apply(pred3.gren1, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc3.gren2 <- apply(pred3.gren2, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc3.gren3 <- apply(pred3.gren3, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # 
> # auc3.enet1 <- apply(pred3.enet1, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc3.enet2 <- apply(pred3.enet2, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc3.enet3 <- apply(pred3.enet3, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # 
> # results3 <- list(idtrain=idtrain,
> #                  pred=list(enet1=pred3.enet1, enet2=pred3.enet2, 
> #                            enet3=pred3.enet3, gren1=pred3.gren1, 
> #                            gren2=pred3.gren2, gren3=pred3.gren3),
> #                  psel=list(enet1=psel3.enet1, enet2=psel3.enet2, 
> #                            enet3=psel3.enet3, gren1=psel3.gren1, 
> #                            gren2=psel3.gren2, gren3=psel3.gren3),
> #                  auc=list(enet1=auc3.enet1, enet2=auc3.enet2, enet3=auc3.enet3, 
> #                           gren1=auc3.gren1, gren2=auc3.gren2, gren3=auc3.gren3))
> # 
> # plot(sort(results3$psel$enet1), results3$auc$enet1[order(results3$psel$enet1)], 
> #      type="l", xlim=range(results3$psel), ylim=range(results3$auc), lty=2,
> #      col=colors[1])
> # lines(sort(results3$psel$enet2), results3$auc$enet2[order(results3$psel$enet2)],
> #       lty=2, col=colors[2])
> # lines(sort(results3$psel$enet3), results3$auc$enet3[order(results3$psel$enet2)],
> #       lty=2, col=colors[3])
> # 
> # lines(sort(results3$psel$gren1), results3$auc$gren1[order(results3$psel$gren1)],
> #       lty=1, col=colors[1])
> # lines(sort(results3$psel$gren2), results3$auc$gren2[order(results3$psel$gren2)],
> #       lty=1, col=colors[2])
> # lines(sort(results3$psel$gren3), results3$auc$gren3[order(results3$psel$gren3)],
> #       lty=1, col=colors[3])
> # 
> # leglabels <- c(expression(alpha==0.05), expression(alpha==0.5),
> #                expression(alpha==0.95), "gren", "enet")
> # legend("bottomright", merge=TRUE, seg.len=1, cex=1.3, fill=c(colors, 0, 0), 
> #        lty=c(rep(NA, length(colors)), 1, 2), 
> #        lwd=c(rep(NA, length(colors)), 1.5, 1.5),
> #        border=c(rep(1, length(colors)), 0, 0), legend=leglabels)
> # 
> # 
> # 
> # 
> # 
> # ####
> # fit4.gren1 <- gren(xtrain, ytrain, partitions=list(RSDqc=part4), alpha=0.05)
> # fit4.gren2 <- gren(xtrain, ytrain, partitions=list(RSDqc=part4), alpha=0.5)
> # fit4.gren3 <- gren(xtrain, ytrain, partitions=list(RSDqc=part4), alpha=0.95)
> # 
> # pred4.gren1 <- predict(fit4.gren1, xtest, type="groupreg",
> #                        s=fit4.gren1$freq.model$groupreg$lambda)
> # pred4.gren2 <- predict(fit4.gren2, xtest, type="groupreg",
> #                        s=fit4.gren2$freq.model$groupreg$lambda)
> # pred4.gren3 <- predict(fit4.gren3, xtest, type="groupreg",
> #                        s=fit4.gren3$freq.model$groupreg$lambda)
> # 
> # pred4.enet1 <- predict(fit4.gren1, xtest, type="regular",
> #                        s=fit4.gren1$freq.model$regular$lambda)
> # pred4.enet2 <- predict(fit4.gren2, xtest, type="regular",
> #                        s=fit4.gren2$freq.model$regular$lambda)
> # pred4.enet3 <- predict(fit4.gren3, xtest, type="regular",
> #                        s=fit4.gren3$freq.model$regular$lambda)
> # 
> # psel4.gren1 <- fit4.gren1$freq.model$groupreg$df
> # psel4.gren2 <- fit4.gren2$freq.model$groupreg$df
> # psel4.gren3 <- fit4.gren3$freq.model$groupreg$df
> # 
> # psel4.enet1 <- fit4.gren1$freq.model$regular$df
> # psel4.enet2 <- fit4.gren2$freq.model$regular$df
> # psel4.enet3 <- fit4.gren3$freq.model$regular$df
> # 
> # auc4.gren1 <- apply(pred4.gren1, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc4.gren2 <- apply(pred4.gren2, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc4.gren3 <- apply(pred4.gren3, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # 
> # auc4.enet1 <- apply(pred4.enet1, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc4.enet2 <- apply(pred4.enet2, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # auc4.enet3 <- apply(pred4.enet3, 2, function(pred) {pROC::roc(ytest, pred)$auc})
> # 
> # results4 <- list(idtrain=idtrain,
> #                  pred=list(enet1=pred4.enet1, enet2=pred4.enet2, 
> #                            enet3=pred4.enet3, gren1=pred4.gren1, 
> #                            gren2=pred4.gren2, gren3=pred4.gren3),
> #                  psel=list(enet1=psel4.enet1, enet2=psel4.enet2, 
> #                            enet3=psel4.enet3, gren1=psel4.gren1, 
> #                            gren2=psel4.gren2, gren3=psel4.gren3),
> #                  auc=list(enet1=auc4.enet1, enet2=auc4.enet2, enet3=auc4.enet3, 
> #                           gren1=auc4.gren1, gren2=auc4.gren2, gren3=auc4.gren3))
> # 
> # plot(sort(results4$psel$enet1), results4$auc$enet1[order(results4$psel$enet1)], 
> #      type="l", xlim=range(results4$psel), ylim=range(results4$auc), lty=2,
> #      col=colors[1])
> # lines(sort(results4$psel$enet2), results4$auc$enet2[order(results4$psel$enet2)],
> #       lty=2, col=colors[2])
> # lines(sort(results4$psel$enet3), results4$auc$enet3[order(results4$psel$enet2)],
> #       lty=2, col=colors[3])
> # 
> # lines(sort(results4$psel$gren1), results4$auc$gren1[order(results4$psel$gren1)],
> #       lty=1, col=colors[1])
> # lines(sort(results4$psel$gren2), results4$auc$gren2[order(results4$psel$gren2)],
> #       lty=1, col=colors[2])
> # lines(sort(results4$psel$gren3), results4$auc$gren3[order(results4$psel$gren3)],
> #       lty=1, col=colors[3])
> 
> proc.time()
      user     system    elapsed 
428882.624    387.216 429312.398 
