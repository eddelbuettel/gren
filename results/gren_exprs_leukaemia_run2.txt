/bin/bash: warning: setlocale: LC_ALL: cannot change locale (UTF-8)

R version 3.4.4 (2018-03-15) -- "Someone to Lean On"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

During startup - Warning messages:
1: Setting LC_CTYPE failed, using "C" 
2: Setting LC_COLLATE failed, using "C" 
3: Setting LC_TIME failed, using "C" 
4: Setting LC_MESSAGES failed, using "C" 
5: Setting LC_MONETARY failed, using "C" 
6: Setting LC_PAPER failed, using "C" 
7: Setting LC_MEASUREMENT failed, using "C" 
> ### paths
> path.data <- "/Users/magnusmunch/Documents/OneDrive/PhD/EBEN/data/"
> path.res <- ifelse(as.character(Sys.info()[1])!="Darwin", "~/EBEN/results/",
+                    "/Users/magnusmunch/Documents/OneDrive/PhD/EBEN/results/")
> 
> ### loading libraries
> library(golubEsets)
Loading required package: Biobase
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: 'BiocGenerics'

The following objects are masked from 'package:parallel':

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following objects are masked from 'package:stats':

    IQR, mad, sd, var, xtabs

The following objects are masked from 'package:base':

    Filter, Find, Map, Position, Reduce, anyDuplicated, append,
    as.data.frame, cbind, colMeans, colSums, colnames, do.call,
    duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted,
    lapply, lengths, mapply, match, mget, order, paste, pmax, pmax.int,
    pmin, pmin.int, rank, rbind, rowMeans, rowSums, rownames, sapply,
    setdiff, sort, table, tapply, union, unique, unsplit, which,
    which.max, which.min

Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.

> library(hu6800.db)
Loading required package: AnnotationDbi
Loading required package: stats4
Loading required package: IRanges
Loading required package: S4Vectors

Attaching package: 'S4Vectors'

The following object is masked from 'package:base':

    expand.grid

Loading required package: org.Hs.eg.db


> library("KEGGREST")
> library(gren) 
> library(GRridge)
Loading required package: penalized
Loading required package: survival
Welcome to penalized. For extended examples, see vignette("penalized").
Loading required package: Iso
Iso 0.0-17
Loading required package: graph
Loading required package: glmnet
Loading required package: Matrix

Attaching package: 'Matrix'

The following object is masked from 'package:S4Vectors':

    expand

Loading required package: foreach
Loaded glmnet 2.0-16

Loading required package: mvtnorm

Attaching package: 'GRridge'

The following object is masked from 'package:glmnet':

    auc

> library(pROC)
Type 'citation("pROC")' for a citation.

Attaching package: 'pROC'

The following objects are masked from 'package:GRridge':

    auc, roc

The following object is masked from 'package:glmnet':

    auc

The following objects are masked from 'package:IRanges':

    cov, var

The following objects are masked from 'package:S4Vectors':

    cov, var

The following object is masked from 'package:BiocGenerics':

    var

The following objects are masked from 'package:stats':

    cov, smooth, var

> 
> ### reading in data
> data(Golub_Merge)
> data(Golub_Test)
> data(Golub_Train)
> 
> ### extracting disease and pathway information from KEGG
> # columns(hu6800.db) shows all available info
> namemap <- as.data.frame(hu6800ALIAS2PROBE)
> entrezmap <- as.data.frame(hu6800ENTREZID)
> genenames <- namemap[match(rownames(fData(Golub_Merge)), namemap[, 1]), 2]
> entrezids <- entrezmap[match(rownames(fData(Golub_Merge)), entrezmap[, 1]), 2]
> 
> # keeping only the known genes
> entrezids2 <- entrezids[!is.na(entrezids)]
> genenames2 <- genenames[!is.na(genenames)]
> 
> # extract number of cancer pathways and diseases in groups of ten
> cancerpathways <- numeric(length(entrezids2))
> cancers <- numeric(length(entrezids2))
> for(i in 1:ceiling(length(entrezids2)/10)) {
+   ind <- c(((i - 1)*10 + 1):(10*i))
+   ind <- ind[ind <= length(entrezids2)]
+   query <- keggGet(paste("hsa:", entrezids2[ind], sep=""))
+   query.names <- sapply(query, function(q) {q$ENTRY})
+   for(j in 1:length(ind)) {
+     if(any(query.names==entrezids2[ind][j])) {
+       paths <- query[[which(query.names==entrezids2[ind][j])[1]]]$PATHWAY
+       if(!is.null(query[[which(query.names==entrezids2[ind][j])[1]]]$DISEASE)) {
+         diseases <- query[[which(query.names==entrezids2[ind][j])[1]]]$DISEASE
+       } else {
+         diseases <- NA
+       }
+       cancers[ind][j] <- sum(grepl("cancer", diseases))
+       cancerpathways[ind][j] <- sum(grepl("cancer", paths))
+     } else {
+       cancerpathways[ind][j] <- NA
+       cancers[ind][j] <- NA
+     }
+   }
+ }
> 
> # setting any genes without pathways and diseases to 0
> cancerpathways2 <- replace(cancerpathways, which(is.na(cancerpathways)), 0)
> cancers2 <- replace(cancers, which(is.na(cancers)), 0)
> # save(cancerpathways2, cancers2,
> #      file=paste(path.data, "gren_exprs_leukaemia_codata.Rdata", sep=""))
> # load(paste(path.data, "gren_exprs_leukaemia_codata.Rdata", sep=""))
> 
> ### data preparation
> # creating the partitioning
> part1 <- as.numeric((cancerpathways2 > 1) + (cancerpathways2 > 0)) + 1
> part2 <- as.numeric(cancers2 > 0) + 1
> 
> # keeping only the known genes
> data <- exprs(Golub_Merge)
> datatest <- exprs(Golub_Test)
> datatrain <- exprs(Golub_Train)
> data2 <- data[!is.na(entrezids), ]
> datatest2 <- datatest[!is.na(entrezids), ]
> datatrain2 <- datatrain[!is.na(entrezids), ]
> 
> # scaling data
> x <- scale(t(data2))
> xtest <- scale(t(datatest2))
> xtrain <- scale(t(datatrain2))
> y <- as.numeric(pData(Golub_Merge)$ALL.AML) - 1
> ytest <- as.numeric(pData(Golub_Test)$ALL.AML) - 1
> ytrain <- as.numeric(pData(Golub_Train)$ALL.AML) - 1
> 
> ### fitting the models
> psel <- c(seq(1, 10, 1), seq(12, 30, 2), seq(35, 50, 5))
> fit2.gren1 <- gren(x, y, partitions=list(pathways=part2), alpha=0.05, psel=psel)
Estimating global lambda by cross-validation
Estimated global lambda is 0.08 in 13.44 seconds
Estimating penalty multipliers by empirical Bayes
Estimated penalty multipliers for pathways: 1 (1), 0.83 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.83 (2)      Penalty multipliers estimated at pathways: 1, 0.83 in 16.79 seconds > fit2.gren2 <- gren(x, y, partitions=list(pathways=part2), alpha=0.5, psel=psel)
Estimating global lambda by cross-validation
Estimated global lambda is 0.01 in 6.65 seconds
Estimating penalty multipliers by empirical Bayes
Estimated penalty multipliers for pathways: 1 (1), 0.85 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.84 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.84 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.84 (2)      Penalty multipliers estimated at pathways: 1, 0.84 in 32.22 seconds > fit2.gren3 <- gren(x, y, partitions=list(pathways=part2), alpha=0.95, psel=psel)
Estimating global lambda by cross-validation
Estimated global lambda is 0.01 in 6.05 seconds
Estimating penalty multipliers by empirical Bayes
Estimated penalty multipliers for pathways: 1 (1), 0.99 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.98 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.98 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.98 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.98 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.98 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.97 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.96 (2)      Estimated penalty multipliers for pathways: 1 (1), 0.95 (2)      Penalty multipliers estimated at pathways: 1, 0.95 in 186.18 seconds > 
> fit2.grridge <- vector("list", length(psel))
> invisible(capture.output(
+   fit2.grridge[[1]] <- grridge(t(x), y, partitions=list(
+     pathways=CreatePartition(as.factor(part2))), selection=TRUE, maxsel=psel[1],
+     trace=FALSE, standardizeX=FALSE)))
> for(s in 2:length(psel)) {
+   invisible(capture.output(
+     fit2.grridge[[s]] <- grridge(t(x), y, partitions=list(
+       pathways=CreatePartition(as.factor(part2))), selection=TRUE, 
+       maxsel=psel[s], optl=fit2.grridge[[1]]$optl, trace=FALSE, 
+       standardizeX=FALSE)))
+ }
> 
> ### calculating performance by cross-validation
> set.seed(2018)
> n <- nrow(x)
> p <- ncol(x)
> nfolds <- n
> rest <- n %% nfolds
> foldid <- sample(rep(1:nfolds, times=round(c(rep(
+   n %/% nfolds + as.numeric(rest!=0), times=rest),
+   rep(n %/% nfolds, times=nfolds - rest)))))
> 
> pred2 <- list(ridge=numeric(n),
+               grridge=matrix(NA, nrow=n, ncol=length(psel)),
+               enet1=matrix(NA, nrow=n, ncol=length(psel)),
+               enet2=matrix(NA, nrow=n, ncol=length(psel)),
+               enet3=matrix(NA, nrow=n, ncol=length(psel)),
+               gren1=matrix(NA, nrow=n, ncol=length(psel)),
+               gren2=matrix(NA, nrow=n, ncol=length(psel)),
+               gren3=matrix(NA, nrow=n, ncol=length(psel)))
> psel2 <- list(grridge=matrix(NA, nrow=n, ncol=length(psel)),
+               enet1=matrix(NA, nrow=n, ncol=length(psel)),
+               enet2=matrix(NA, nrow=n, ncol=length(psel)),
+               gren1=matrix(NA, nrow=n, ncol=length(psel)),
+               enet3=matrix(NA, nrow=n, ncol=length(psel)),
+               gren2=matrix(NA, nrow=n, ncol=length(psel)),
+               gren3=matrix(NA, nrow=n, ncol=length(psel)))
> 
> 
> for(k in 1:nfolds) {
+   set.seed(2018 + k)
+   cat(paste("Fold ", k, "\n"))
+   
+   xtrain <- scale(x[foldid!=k, ])
+   xtest <- matrix(x[foldid==k, ], ncol=p, byrow=TRUE)
+   ytrain <- y[foldid!=k]
+   
+   cv2.ridge <- cv.glmnet(xtrain, ytrain, alpha=0, standardize=FALSE)
+   
+   cv2.grridge <- vector("list", length(psel))
+   invisible(capture.output(
+     cv2.grridge[[1]] <- grridge(t(xtrain), ytrain, partitions=list(
+       pathways=CreatePartition(as.factor(part2))), selection=TRUE, 
+       maxsel=psel[1], trace=FALSE, standardizeX=FALSE)))
+   for(s in 2:length(psel)) {
+     invisible(capture.output(
+       cv2.grridge[[s]] <- grridge(t(xtrain), ytrain, partitions=list(
+         pathways=CreatePartition(as.factor(part2))), selection=TRUE, 
+         maxsel=psel[s], optl=cv2.grridge[[1]]$optl, trace=FALSE, 
+         standardizeX=FALSE)))
+   }
+   
+   cv2.gren1 <- gren(xtrain, ytrain, partitions=list(pathways=part2), alpha=0.05, 
+                     psel=psel, trace=FALSE)
+   cv2.gren2 <- gren(xtrain, ytrain, partitions=list(pathways=part2), alpha=0.5, 
+                     psel=psel, trace=FALSE)
+   cv2.gren3 <- gren(xtrain, ytrain, partitions=list(pathways=part2), alpha=0.95, 
+                     psel=psel, trace=FALSE)
+   
+   # predictions
+   pred2$ridge[foldid==k] <- as.numeric(predict(cv2.ridge, xtest, "lambda.min"))
+   
+   pred2$grridge[foldid==k, ] <- sapply(cv2.grridge, function(s) {
+     predict.grridge(s, t(xtest))[, 3]})
+   
+   pred2$gren1[foldid==k, ] <- predict(cv2.gren1, xtest, type="groupreg",
+                                       s=cv2.gren1$freq.model$groupreg$lambda)
+   pred2$gren2[foldid==k, ] <- predict(cv2.gren2, xtest, type="groupreg",
+                                       s=cv2.gren2$freq.model$groupreg$lambda)
+   pred2$gren3[foldid==k, ] <- predict(cv2.gren3, xtest, type="groupreg",
+                                       s=cv2.gren3$freq.model$groupreg$lambda)
+   
+   pred2$enet1[foldid==k, ] <- predict(cv2.gren1, xtest, type="regular",
+                                       s=cv2.gren1$freq.model$regular$lambda)
+   pred2$enet2[foldid==k, ] <- predict(cv2.gren2, xtest, type="regular",
+                                       s=cv2.gren2$freq.model$regular$lambda)
+   pred2$enet3[foldid==k, ] <- predict(cv2.gren3, xtest, type="regular",
+                                       s=cv2.gren3$freq.model$regular$lambda)
+   
+   # number of selected variables
+   psel2$grridge[foldid==k, ] <- sapply(cv2.grridge, function(s) {
+     length(s$resEN$whichEN)})
+   
+   psel2$gren1[foldid==k, ] <- cv2.gren1$freq.model$groupreg$df
+   psel2$gren2[foldid==k, ] <- cv2.gren2$freq.model$groupreg$df
+   psel2$gren3[foldid==k, ] <- cv2.gren3$freq.model$groupreg$df
+   
+   psel2$enet1[foldid==k, ] <- cv2.gren1$freq.model$regular$df
+   psel2$enet2[foldid==k, ] <- cv2.gren2$freq.model$regular$df
+   psel2$enet3[foldid==k, ] <- cv2.gren3$freq.model$regular$df
+   
+   results2 <- list(pred=pred2, psel=psel2)
+   save(results2, file=paste(path.res, "gren_exprs_leukaemia_res2.Rdata", sep=""))
+ }
Fold  1 
Fold  2 
Fold  3 
Fold  4 
Fold  5 
Fold  6 
Fold  7 
Fold  8 
Fold  9 
Fold  10 
Fold  11 
Fold  12 
Fold  13 
Fold  14 
Fold  15 
Fold  16 
Fold  17 
Fold  18 
Fold  19 
Fold  20 
Fold  21 
Fold  22 
Fold  23 
Fold  24 
Fold  25 
Fold  26 
Fold  27 
Fold  28 
Fold  29 
Fold  30 
Fold  31 
Fold  32 
Fold  33 
Fold  34 
Fold  35 
Fold  36 
Fold  37 
Fold  38 
Fold  39 
Fold  40 
Fold  41 
Fold  42 
Fold  43 
Fold  44 
Fold  45 
Fold  46 
Fold  47 
Fold  48 
Fold  49 
Fold  50 
Fold  51 
Fold  52 
Fold  53 
Fold  54 
Fold  55 
Fold  56 
Fold  57 
Fold  58 
Fold  59 
Fold  60 
Fold  61 
Fold  62 
Fold  63 
Fold  64 
Fold  65 
Fold  66 
Fold  67 
Fold  68 
Fold  69 
Fold  70 
Fold  71 
Fold  72 
> 
> 
> 
> 
> 
> 
> # ### calculating predictive performance on test set
> # cv2.gren1 <- gren(xtrain, ytrain, partitions=list(pathways=part2), alpha=0.5)
> # cv2.grridge <- grridge(t(xtrain), as.factor(ytrain), 
> #                        list(pathways=CreatePartition(as.factor(part2))))
> # cv2.test1 <- glmnet(xtrain, ytrain, family="binomial", alpha=0.5)
> # pred2.test1 <- predict(cv2.test1, xtest, type="response")
> # 
> # pred2.gren1 <- predict(cv2.gren1$freq.model$groupreg, xtest, type="response")
> # pred2.enet1 <- predict(cv2.gren1$freq.model$regular, xtest, type="response")
> # pred2.grridge <- predict.grridge(cv2.grridge, t(xtest))[, 2]
> # 
> # psel2.gren1 <- cv2.gren1$freq.model$groupreg$df
> # psel2.enet1 <- cv2.gren1$freq.model$regular$df
> # psel2.test1 <- cv2.test1$df
> # 
> # pred2.grridge <- predict.grridge(cv2.grridge, t(xtest))[, 2]
> # pred2.ridge <- predict.grridge(cv2.grridge, t(xtest))[, 1]
> # 
> # auc2.gren1 <- apply(pred2.gren1, 2, function(s) {pROC::auc(ytest, s)})
> # auc2.enet1 <- apply(pred2.enet1, 2, function(s) {pROC::auc(ytest, s)})
> # auc2.grridge <- pROC::auc(ytest, pred2.grridge)
> # auc2.test1 <- apply(pred2.test1, 2, function(s) {pROC::auc(ytest, s)})
> # 
> # plot(psel2.gren1, auc2.gren1, type="l")
> # lines(psel2.enet1, auc2.enet1, col=2)
> # lines(psel2.test1, auc2.test1, col=3)
> 
> proc.time()
     user    system   elapsed 
37450.000   126.152 37843.177 
